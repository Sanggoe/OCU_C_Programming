#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct ListNode { //단순 연결 리스트의 노드 구조를 구조체로 정의
   char data[4];
   struct ListNode* link;
} listNode;

typedef struct linkedList_h{ //리스트 시작을 나타내는 head노드를 구조체로 정의
   listNode* head;
} linkedList_h;

linkedList_h* createLinkedList_h(void) { //공백연결 리스트를 생성하는 연산
   linkedList_h* L;
   L = (linkedList_h*)malloc(sizeof(linkedList_h));
   L->head = NULL; //공백 리스트이므로 NULL로 설정
   return L;
}

void freeLinkedList_h(linkedList_h* L) { //연결 리스트의 전체 메모리를 해제하는 연산
   listNode* p;
   while (L->head != NULL) {
      p = L->head;
      L->head = L->head->link;
      free(p);
      p = NULL;
   }
}

void printList(linkedList_h* L) { //연결 리시트를 순서대로 출력하는 연산
   listNode* p;
   printf("L=(");
   p = L->head;
   while (p != NULL) {
      printf("%s", p->data);
      p = p->link;
      if (p != NULL) printf(",");
   }
   printf(")\n");
}

void insertFirstNode(linkedList_h* L, char* x) {
   listNode* newNode;
   newNode = (listNode*)malloc(sizeof(listNode));
   strcpy_s(newNode->data, sizeof(newNode), x);
   newNode->link = L->head;
   L->head = newNode;
} //첫 번째 노드로 삽입하는 연산

void insertMiddleNode(linkedList_h* L, listNode* pre, char* x) {
   listNode* newNode;
   newNode = (listNode*)malloc(sizeof(listNode));
   strcpy_s(newNode->data, sizeof(newNode), x);
   if (L == NULL) { //공백 리스트인 경우
      newNode->link = NULL; // 새 노드를 첫 번째이자 마지막 노드로 연결
      L->head = newNode;
   }
   else if (pre == NULL) { //삽입 위치를 지정하는 포인터 pre가 NULL인 경우
      L->head = newNode; //새 노드를 첫 번째 노드로 삽입
   }
   else {
      newNode->link = pre->link; //포인터 pre의 노드 뒤에 새 노드 연결
      pre->link = newNode;
   }
}//노드를 pre 뒤 즉 중간에 삽입하는 연산
void insertLastNode(linkedList_h* L, char* x) {
   listNode* newNode;
   listNode* temp;

   newNode = (listNode*)malloc(sizeof(listNode));
   strcpy_s(newNode->data, sizeof(newNode), x);
   newNode->link = NULL;
   if (L->head == NULL) { //현재 리스트가 공백인 경우
      L->head = newNode; //새 노드를 리스트의 시작 노드로 연결
      return;
   }

   temp = L->head; //현재 리스트가 공백이 아닌경우
   while (temp->link != NULL)temp = temp->link; //현재 리스트의 마지막 노드를 찾음
   temp->link = newNode; //새 노드를 마지막 노드(temp)의 다음 노드로 연결
}//마지막 노드로 삽입하는 연산

listNode* searchNode(linkedList_h* L, char* x) {
   listNode* temp;
   temp = L->head;
   while (temp != NULL) {
      if (strcmp(temp->data,x) == 0)return temp;
      else temp = temp->link;
   }
   return temp;
}

int main() {
   linkedList_h* L;
   listNode* p;
   L = createLinkedList_h();
   printf("(1) 공백 리스트 생성하기! \n");
   printList(L); getchar();

   printf("(2) 리스트에 [수] 노드 삽입하기! \n");
   insertFirstNode(L, "수");
   printList(L); getchar();

   printf("(3) 리스트 마지막에 [금] 노드 삽입하기! \n");
   insertLastNode(L, "금");
   printList(L); getchar();

   printf("(4) 리스트 첫 번째 누드 [수] 뒤에 [월] 노드 삽입하기! \n");
   p = searchNode(L, "수");
   insertMiddleNode(L,p,"월");
   printList(L); getchar();

   printf("(5) 리스트 공간을 해제하여 공백 리스트로 만들기! \n");
   freeLinkedList_h(L);
   printList(L); getchar();

   getchar();

   return 0;
}